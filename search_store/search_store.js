var fs = require('fs');

/**
 * This module encapsulate all data processing and search methods.
 */
function SearchStore() {

    //private members


    /** 
     * @description It store names as HashMap where hash key is equal to line number on which name
     *  appears in csv file and value is the name itself
     */
    let primaryHashTable;

    /**
     * @description It stores reference key from primaryHashTable against every possible suffix of name.
     * Suffix which are 3 or more characters long is only stored. It serve as main data structure for 
     * our search api.
     */
    let searchMultiHashMap;


    /**
     * Initializes private variables of module
     * @description It initializes primaryHashTable and searchMultiHashMap using
     * createPrimaryHashTable() & addToSearchMap() methods.
     * @param {string} data data read from csv file
     */
    createSearchDataSet = (data) => {
        createPrimaryHashTable(data);

        // For each key in primaryHashTable generate suffix and add to searchMultiHashMap object
        for (let key in this.primaryHashTable) {
            let suffix_array = generateSuffixKeys(this.primaryHashTable[key].replace(/\s/g, '').toLowerCase());

            addToSearchMap(suffix_array, key);
        }
    }

    /**
     * This method initializes primaryHashTable variable with names read from csv file
     * @param {string} namesList data read from csv file
     */
    createPrimaryHashTable = (namesList) => {

        let i = 0;
        let hash_table = {};

        // Split names based on newline character and then store as per occurence in file as key.
        // Slice(1) is used to remove header row from data
        namesList.split('\n').slice(1).forEach(element => {
            if (element.trim() !== null && element.trim() !== undefined && element.trim() !== '')
                hash_table[i] = element.split(',').join(' ').toString();
            i++;
        });

        //assign primary hash table with local hash table
        this.primaryHashTable = hash_table;
    }

    /**
     * Creates all possible suffix of name with length >= 3
     * @param {string} name string for which suffix is to be generated
     * 
     * @returns {Array} return array of suffixes
     * 
     * For string 'james' it generates following output
     * @example
     *  return ['jam', 'ame', 'mes', 'jame', 'ames', 'james']
     */
    generateSuffixKeys = (name) => {
        let window = 3;
        const arr = []
        while (window <= name.length) {
            for (let start_pos = 0; start_pos <= name.length - window; start_pos++) {
                arr.push(name.substring(start_pos, window + start_pos));
            }
            ++window;
        }

        return arr;
    }

    /**
     * It add name reference key as value and their suffix as key in searchMultiHashMap object. 
     * @param {Array} suffix_array array with suffixes of a name, generated by generateSuffixKeys(name)
     * @param {int} key reference key of the name from primaryHashTable
     */
    addToSearchMap = (suffix_array, key) => {

        if (this.searchMultiHashMap === undefined)
            this.searchMultiHashMap = {};

        /**
         * For each suffix check if suffix key already present then add reference key 
         * to that value array. Otherwise create new key and add reference key to its 
         * newly initialized value array.
         */
        suffix_array.forEach(elem => {
            if (Array.isArray(this.searchMultiHashMap[elem]))
                this.searchMultiHashMap[elem].push(key);
            else {
                this.searchMultiHashMap[elem] = [];
                this.searchMultiHashMap[elem].push(key);
            }
        });
    }


    /**
     * It gets original names from primaryHashTable based on reference key list
     * @param {Array} key_list list of reference keys for name to be fetched from primaryHashtable
     * @param {string} query search term against which search was performed
     */
    getNamesFromPrimaryHashTable = (key_list, query) => {
        const names = [];

        // If key list empty i.e. no match found return
        if (key_list === undefined)
            return;

        // For each key create JSON object containing real name and relevance score and add it to final array
        key_list.forEach(item => {
            let result = {}
            result.name = this.primaryHashTable[item];
            result.score = getNameScore(query, this.primaryHashTable[item]);
            names.push(result);
        })
        // return data
        return names;
    }

    /**
     * It calculates relevance score for name against search term
     * @description Relevance score is calculated on two factor
     * 1) Size of result i.e shorter is preferred 
     * 2) Position of search term in result
     * Criteria is given 3:7 weightage. Total score is out of 10.
     * 
     * @param {string} searchTerm search term against which search was performed
     * @param {string} name for which score is to be generated 
     * @returns {number} relevance score
     */
    getNameScore = (searchTerm, name) => {

        name = name.replace(/\s/g, '').toLowerCase();
        searchTerm = searchTerm.replace(/\s/g, '').toLowerCase();
        
        //Calculation based on result length
        const perDecrementForLength = generateNetPercentageDecrease(name.length - searchTerm.length, 0);
        const sizeScore = 3 + (3 * perDecrementForLength / 100);

        //Calculation based on substring position
        const perDecrementForPosition = generateNetPercentageDecrease(name.indexOf(searchTerm), 0);
        const positionScore = 7 + (7 * perDecrementForPosition / 100);

        // return final score
        return sizeScore + positionScore;
    }


    /**
     * It generated net percentage descrese using successive percentage formula
     * @param {int} diff variation between original name and search term
     * @param {number} per effective percentage of decrement to be applied to score
     */
    generateNetPercentageDecrease = (diff, per) => {

        if (diff === 0) {
            return per;
        }

        per = (per - 2 + (per * 2 / 100))

        return generateNetPercentageDecrease(--diff, per);
    }


    //public methods

    /**
     * It initializes the data structure to allow search api to work
     * @param {cb} callback method to notify caller when async read finished
     */
    this.init = (cb) => {

        fs.readFile('./data/data.csv', 'UTF-8', (err, data) => {
            if (err)
                cb(err, null)
            else {
                createSearchDataSet(data);
                cb(null, data);
            }
        })

    }

    /**
     * It searches the search key in searchMultiHashMap object to fetch relevant names
     * 
     * @description It search key in searchMultiHashMap. The search will yield reference keys of all
     * relevant names where that search term is present. Then for each reference key get original name
     * and relevance score using getNamesFromPrimaryHashTable. At last sort the result based
     * on relevance score and return the result
     * 
     * @param {string} query it is search term received in request parameters
     */
    this.searchInMap = (query) => {

        // uncomment this line to log time taken for search to respond
        // console.time('search');
        
        
        const nameKeys = this.searchMultiHashMap[query];

        //return if no match found
        if (nameKeys === undefined)
            return;

        const result = getNamesFromPrimaryHashTable(nameKeys, query);
        result.sort(function (a, b) {
            return a.score == b.score ? 0 : +(a.score < b.score) || -1;
        });

        // uncomment this line to log time taken for search to respond
        // console.timeEnd('search');


        // return result
        return result;

    }


    // Code required for getNameScore method testing: can be removed from production
    this._testScore = getNameScore;
    // Test case code ends here


}

//Export the module with name SearchStore
module.exports.SearchStore = SearchStore;
